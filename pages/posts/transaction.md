---
title: 憧憬成为 web3 高手之：Ethereum 交易与签名
date: 2024-07-15
updated: 2024-07-15
categories: Web3相关
tags:
  - web3
  - 笔记
  - ethereum
top: 1
---
# 交易

交易是由**外部账户**发起的**签名**消息。

是唯一可以触发状态更改或者导致合约在 EVM 执行的东西

## 交易的结构

- nonce: 由 EOA 发起的序列号，防止消息被重拨
- gas price: 发起人愿意支付的 gas 价格
- start gas: 发起人愿意支付的最大 gas 量
- to: 目标以太坊地址
- value: 发送到目标地址的 ether 数量
- data: 变长二进制数据
- v, r, s: 始发EOA的ECDSA签名的三个组成部分

交易消息结构使用 `递归长度前缀(RLP)` 编码方案经行序列化，RLP 的长度前缀用于标识每个字段的长度，超出定义长度的任何内容属于结构中的下一字段。以太坊中所有数字都被编码为大端序整数，长度为8的倍数。

### nonce

与次地址发送的交易数量相等的标量值，对于具有关联代码的账户，表示账户创建的交易数量。

nonce 是始发地址的一个属性，但并未作为账户的一部分显式存储在区块链中，根据来源此地址的已确认的数量动态计算的。

使用 nonce 确保所有节点计算相同的余额，并正确的对交易经行排序。相当于比特币中防止“双重支付”的机制。由于以太坊跟踪账户余额而不是独立的币（在比特币中被成为 UTXO ），所以只有在账户余额计算错误时才会发生“双花”，nonce 机制可以防止这种情况发生

#### 跟踪 nonce

编程式创建交易时，跟踪 nonce 是非常重要的。

以太坊网络根据 nonce 顺序处理交易，当接收到的交易 nonce 中断时，他会搁置交易直到接收到缺失的交易。

### gas

gas 是以太坊的燃料，区别于 ether， 它是独立的虚拟货币，有相对于 ether 的汇率。以太坊使用 gas 来控制交易可以花费的资源量（基于整个以太坊网络的算力）。开放式的计算模型需要某种形式的计量，以防拒绝服务攻击或资源吞噬攻击。

gas 与 ether 分离，以保护系统免受随着 ether 价值快速变化而产生的波动。

交易中的 `gas price` 字段允许交易发起者设置每单位 gas 的汇率，以控制交易的 gas 费用。越高的交易越容易被开采。

### 交易的接收者

以太坊不验证接收地址的有效性，任何 20 字节的值都被认为是有效的。验证地址有效性这一步应在用户界面层级来完成。

发送至一个无效地址的 ether 将会被**燃烧**。燃烧 ether 被以太坊认为是合法且合理的行为。

### 交易的价值和数据

`value` 与 `data`，可以随意组合，可以两者都有，可以都没有。

只有 value 的交易是*支付 payment*，只有 data 的交易是*调用 invocation*。既没有 value 也没有 data 的交易只能是浪费 gas，但它仍是可能的。

#### 特殊交易：合约注册

一种特殊的带有 data，没有 value 的交易。表示注册一个新的合约。合约注册交易被发送至一个特殊的地址，零地址：`0x0`。此地址既不代表 EOA 也不代表合约。

合约注册交易不应该包含 ether value，只能包含合约编译字节码的data。合约需要编译为二进制码以十六进制表示。这可以被 Solidity 编译器完成。

### 数字签名

不泄漏私钥的情况下提供私钥所有权的证明（零知识证明）

> 数字签名是用于证明数字信息或文件真实性的数学方案。有效的数字签名使收件人有理由相信该信息是由已知的发件人（认证）创建的，发件人不能否认已发送的信息（不可否认），并且信息在传输过程中未被更改（完整性）。[wikipedia](https://en.wikipedia.org/wiki/Digital_signature_)

---

数字签名是一种数学签名，由两部分组成：
- 使用私钥从消息中创建签名
- 任何人可以使用公钥+消息来验证签名有效性

#### 创建数字签名

以太坊实现的 `ECDSA` 中，被签名的“消息”是交易。准确的说，是来自交易的 RLP 编码数据的 `keccak256` 哈希。签名密钥是 EOA 的私钥。结果是签名。

$Sig = F_{sig}(F_{keccak256}(m), k)$

- _k_ 是签名私钥
- _m_ 是RLP编码的交易
- $F_{keccak256}$ 是 Keccak256 哈希函数
- $F_{sig}$ 是签名算法
- _Sig_ 是由此产生的签名

函数 $F_{sig}$ 产生一个由两个值组成的签名 _Sig_，通常称为 _R_ 和 _S_ 

```
    Sig = (R, S)
```

##### ECDSA 数学

签名算法首先生成一堆临时的私钥/公钥对。在涉及签名私钥和交易哈希转换之后，此临时密钥对用于计算 _R_ 和 _S_ 值。

临时密钥对由两个输入值产生:

1. 一个随机数 _q_ ，用于临时私钥
2. 椭圆曲线生成点 _G_

从 _q_ 和 _G_ 我们生成临时的公钥 _Q_ （以 _Q = q * G_ 计算，与以太坊公钥的派生方式相同）。数字签名的 _R_ 值就是临时公钥 _Q_ 的 x 坐标。

然后算法计算签名的 _S_ 值：

---

$S \equiv q^{-1} (Keccak256(m) + k * R)     \pmod p$

其中：
- _q_ 是临时私钥，$q^{-1}$ 是 _q_ 的模的乘法逆元
- _R_ 是临时公钥的 x 坐标
- _k_ 是签名 （EOA 所有者）的私钥
- _m_ 是交易数据
- _p_ 是椭圆曲线的素数阶

---

验证是签名生成函数的反函数，使用 _R_，_S_ 值和公钥来计算一个值 _Q_，它是椭圆曲线上的一个点（签名创建时的临时公钥）:

$Q \equiv S^{-1}*Keccak256(m)*G+S^{-1}*R*K\pmod p$

其中：
- _R_ 和 _S_ 是签名值
- _K_ 是签名者（EOA 所有者）的公钥
- _m_ 是被签名的交易数据
- _G_ 是椭圆曲线的生成点
- _p_ 是椭圆曲线的素数阶

如果计算的点 _Q_ 的 x 坐标等于 _R_，则验证者可以断定该签名是有效的。

---
互逆过程: 

$$ Q \equiv S^{-1} * Keccak256(m) * G + S^{-1} * R * K \pmod p $$
$$ q * G \equiv S^{-1} * Keccak256(m) * G + S^{-1} * R * k * G \pmod p$$
$$ q \equiv S^{-1} * (Keccak256(m) + R * k) \pmod p $$
$$ S \equiv q^{-1} * (Keccak256(m) + R * k) \pmod p $$


::: info

更多ECDSA相关查看

[Understanding How ECDSA Protects Your Data.](https://www.instructables.com/Understanding-how-ECDSA-protects-your-data/)

[一文读懂ECDSA算法如何保护数据](https://zhuanlan.zhihu.com/p/97953640)

:::

#### 验证签名

要验证签名，必须有签名（R，S），序列化交易和公钥（与创建签名的私钥对应）。实质上，验证签名意味着只有生成此**公钥**的**私钥所有者**才能在此交易上产生签名。

#### EIP-155

在 #2,675,000 块，以太坊实施了“Spurious Dragon”硬分叉，除其他修改外，还推出了包括交易重播保护的新签名方案。

EIP-155 向交易数据结构添加了三个字段 _v_，_r_ 和 _s_。_r_ 和 _s_ 被初始化为零，_v_ 被初始化为链的唯一标识符。这三个字段在编码和散列**之前**被添加至交易数据中，因此哈希散列和签名会保证链标识符不会被篡改，提供“简单重播攻击保护”。

发起交易的流程是：

1. 创建一个含有九个字段的交易数据结构
    - nonce
    - gasPrice
    - startGas
    - to
    - value
    - data
    - v
    - r
    - s
2. 生成交易的 RLP 编码的序列化消息
3. 计算此序列的 Keccak256 哈希
4. 计算 ECDSA 签名，用发起 EOA 的私钥签名散列
5. 在交易中插入 ECDSA 签名计算出的 r 和 s 值

